GET REQUEST

/*
 * Return the view of the other taxis from the point of view of the requester (this process/taxi)
 * ----------------------------------------------------------------------------------------------
 * Essentially will perform an HTTP POST request to the "/get-taxis" exposed REST API, which will
 * return the list of all the other taxis present on the administrator server minus the taxi
 * which is making the request ('thisTaxi' variable).
 */
private static ArrayList<TaxiInfo> getTaxisOnServer(Client client, int taxiID) {
	final String GET_PATH = "/get-taxis/" + taxiID;

	Response response = getRequest(client, ADMIN_SERVER_URL + GET_PATH);

	if (response.getStatus() == Response.Status.GONE.getStatusCode()) {
		System.out.println(response.readEntity(String.class));
		System.exit(0);

	}

	String responseJson = null;
	try {
		responseJson = response.readEntity(String.class);
	} catch (Exception ex) {
		ex.printStackTrace();
	}

	return GSON.fromJson(responseJson, ArrayList.class);
}

// Perform an HTTP GET request given the url and the body as json
public static Response getRequest(Client client, String url) {
	WebTarget webTarget = client.target(url);
	Invocation.Builder builder = webTarget.request(MediaType.APPLICATION_JSON_TYPE);
	return builder.get();
}


/////////////////////// Synchronized Grpc coordination
private static int coordinateRideGrpc(double distanceToDestination, int[] destination, boolean isRechargeRide)
		throws InterruptedException {
	IPC.RideCharge proposal = IPC.RideCharge.newBuilder()
			.setTaxi(getIPCInfos())
			.addDestinationPosition(destination[0])
			.addDestinationPosition(destination[1])
			.setDistanceToDestination(distanceToDestination)
			.setRechargingRide(isRechargeRide)
			.build();

	int ackCounter = 0;

	// Send the proposal only to the other taxis in the same district
	for (TaxiInfo t : taxis) {
		if (t.getDistrict() == district) {
			String target = ADMIN_SERVER_ADDRESS + ":" + t.getGrpcPort();
			ManagedChannel channel = ManagedChannelBuilder
					.forTarget(target)
					.usePlaintext()
					.build();
			//todo //System.out.println("Sending my distance to " + target);
			IPCServiceGrpc.IPCServiceBlockingStub stub = IPCServiceGrpc.newBlockingStub(channel);
			IPC.ACK ack = stub.coordinateRide(proposal);
			/* If the client taxi has a smaller distance then another server taxi *
			 * it will receive its own data back (as ACK vote for consensus)      */
			if (ack.getVote()) {
				ackCounter++;
				System.out.println("Received an ACK from " + t.getId());
			} else {
				System.out.println("Received a NACK from " + t.getId());
			}
			channel.shutdown();
		}
	}
	Thread.sleep(500);
	return ackCounter;
}



BATTERIE

/*        Thread batteryThread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) {
                if (battery < 30.0) {
                    try {
                        rechargeBattery();
                    } catch (InterruptedException | MqttException e) {
                        throw new RuntimeException(e);
                    }
                }
            }
        });
        batteryThread.start();
*/

/*
private static void rechargeBattery() throws InterruptedException, MqttException {
	int[] destination = getRechargeStationPosition();
	double distanceToDestination = euclideanDistance(position, destination);

	System.out.println("I got the ownership for the recharge station of the" +
			"district " + district +
			", at position " + Arrays.toString(destination));

	RideInfo rideInfo = new RideInfo();
	rideInfo.setStartPosition(position);
	rideInfo.setDestinationPosition(destination);
	rideInfo.setId(9999);

	isRecharging = true;
	performRide(rideInfo);
	isRecharging = false;
	System.out.println("Reached the recharge station");

	if (!taxis.isEmpty()) {
		final int taxisInDistrict = getNumberOfTaxisInDistrict();
		System.out.println("[Recharging] Waiting for " + taxisInDistrict + " ACK votes");
		final int ackVotes = coordinateRideGrpc(distanceToDestination, destination, true);
		System.out.println("[Recharging] Received a total of " + ackVotes + " ACKs");

		if (ackVotes == taxisInDistrict) {

		} else {
			// The ride has been taken from someone else
			// It should wait of information in case of new position of the taxi
			System.out.println("Moving to the recharge station of district " +
					district + " at position (" + destination[0] + "," + destination[1] + ")");
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				throw new RuntimeException(e);
			}

			System.out.println("I didn't got the ownership for the recharging ride " + rideInfo.getId());
		}
	} else {
		// todo: caso in cui si ricarca subito
	}
}

private static int[] getRechargeStationPosition() {
	int[] destination = new int[2];

	if (district == 1) {
		destination[1] = 1;
	} else if (district == 2) {
		destination[1] = 9;
	} else if (district == 3) {
		destination[0] = 9;
		destination[1] = 9;
	} else if (district == 4) {
		destination[0] = 9;
	}

	return destination;
}
*/